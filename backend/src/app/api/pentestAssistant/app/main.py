import asyncio
import re
import subprocess
import xml.etree.ElementTree as ET
from multiprocessing import Process
from typing import Annotated

from fastapi import APIRouter, Depends, FastAPI, HTTPException
from fastapi.responses import JSONResponse, PlainTextResponse
from fastapi.templating import Jinja2Templates
from sqlalchemy import create_engine
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Session, sessionmaker

from src.app.api.dependencies import get_current_user
from src.app.core.config import settings
from src.app.core.db.database import async_get_db, local_session
from src.app.crud.crud_scan import crud_scan
from src.app.schemas.scan import ScanCreate, ScanCreateInternal, ScanRead

from .crud import (
    append_exploit_log,
    append_nuclei_output,
    append_scan_output,
    create_scan,
    save_report,
    update_scan_status,
)

# ✅ Импорт новой логики
from .exploitation import run_exploit_phase

# Импорт моделей и CRUD
from .models import Base, Scan
from .reporting import ReportGenerator

# --- Конфигурация ---
# ❗️ ВАЖНО: Вынесите этот ключ в переменные окружения в реальном проекте!
# Пример: OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
OPENROUTER_API_KEY = settings.PENTEST_TOKEN


BDU_MAP = {}
NMAP_PATH = "nmap"
NUCLEI_PATH = "nuclei"


def extract_cve_ids(text: str) -> list:
    cve_pattern = r"CVE-\d{4}-\d{4,7}"
    cves = re.findall(cve_pattern, text, re.IGNORECASE)
    return list(set([cve.upper() for cve in cves]))


def build_attack_chain_mermaid(scan_id: int) -> str:
    db = SessionLocal()
    scan = db.query(Scan).filter(Scan.id == scan_id).first()
    db.close()
    if not scan:
        return ""

    all_text = scan.nmap_output + "\n" + scan.nuclei_output
    cve_list = extract_cve_ids(all_text)

    nodes = ["Target", "Port_Scan"]
    edges = []

    if not cve_list:
        edges.append("Port_Scan --> No_CVEs_Found")
    else:
        for cve in cve_list:
            label = cve.replace("-", "_")
            nodes.append(label)
            edges.append(f"Port_Scan --> {label}")
            # Простое условие для примера
            if "2017" in cve or "2021" in cve:  # Условные "опасные" CVE
                edges.append(f"{label} --> Potentially_Critical_Vulnerability")

    edges = list(set(edges))

    mermaid_code = "graph TD;\n"
    for edge in edges:
        mermaid_code += f"  {edge};\n"

    return mermaid_code


# --- Загрузка данных БДУ ---
def load_bdu_map_from_xml():
    global BDU_MAP
    try:
        tree = ET.parse("bdu.xml")
        root = tree.getroot()
        for vul in root.findall(".//vul"):
            cve = next(
                (ident.text.upper() for ident in vul.findall(".//identifier") if "CVE-" in ident.text.upper()),
                None,
            )
            bdu_id = next(
                (ident.text for ident in vul.findall(".//identifier") if "BDU:" in ident.text.upper()),
                None,
            )
            if cve and bdu_id:
                BDU_MAP[cve] = bdu_id
        print(f"Загружено {len(BDU_MAP)} соответствий CVE -> BDU из XML")
    except Exception as e:
        print(f"⚠️ Ошибка загрузки BDU из XML: {e}")


load_bdu_map_from_xml()

# --- Настройка FastAPI и БД ---
app = FastAPI()
templates = Jinja2Templates(directory="templates")

engine = create_engine("sqlite:///./scans.db", connect_args={"check_same_thread": False})
Base.metadata.create_all(bind=engine)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


# --- Эндпоинты ---
app = APIRouter()


# ----------------------
#   ВСПОМОГАТЕЛЬНОЕ
# ----------------------


def get_scan_or_404(db: Session, scan_id: int):
    scan = db.query(Scan).filter(Scan.id == scan_id).first()
    if not scan:
        raise HTTPException(status_code=404, detail="scan not found")
    return scan


@app.get("/scan/my", response_model=list[ScanRead])
async def get_my_scans(user=Depends(get_current_user), db: AsyncSession = Depends(async_get_db)):
    result = await crud_scan.get_multi(
        db=db,
        user_id=user["id"],
        schema_to_select=ScanRead,
    )

    sorted_data = sorted(
        result["data"],
        key=lambda x: x["created_at"],
        reverse=True,  # Новые сверху
    )

    return sorted_data


# -----------------------------
# 1) СТАРТ СКАНИРОВАНИЯ (JSON)
# -----------------------------


@app.post("/scan")
async def api_start_scan(
    db_main: Annotated[AsyncSession, Depends(async_get_db)],
    data: ScanCreate,
    user: Annotated[dict, Depends(get_current_user)],  # noqa: F821
):
    target = data.target
    if not target:
        raise HTTPException(status_code=400, detail="target is required")

    db = SessionLocal()
    scan = create_scan(db, target)
    db.close()

    scan_object = ScanCreateInternal(
        title=data.title, id=str(scan.id), status=scan.status, user_id=user["id"], target=scan.target
    )
    await crud_scan.create(db=db_main, object=scan_object)

    p = Process(target=worker_run_full_scan, args=(scan.id, target))
    p.daemon = True
    p.start()

    return JSONResponse({"scan_id": scan.id, "status": "started"})


# ----------------------------------------
# 2) ПОЛУЧЕНИЕ ИНФОРМАЦИИ О СКАНЕ (JSON)
# ----------------------------------------
@app.get("/scan/{scan_id}")
async def api_get_scan(scan_id: int):
    db = SessionLocal()
    scan = get_scan_or_404(db, scan_id)
    db.close()

    return JSONResponse({"id": scan.id, "target": scan.target, "status": scan.status})


# ----------------------------------------------
# 3) ЛОГИ СКАНИРОВАНИЯ — ВСЕГДА PLAIN TEXT
# ----------------------------------------------
@app.get("/scan/{scan_id}/log")
async def api_get_log(scan_id: int):
    db = SessionLocal()
    scan = get_scan_or_404(db, scan_id)
    db.close()

    full_log = (scan.nmap_output or "") + "\n" + (scan.nuclei_output or "") + "\n" + (scan.exploit_log or "")

    return PlainTextResponse(full_log)


# ---------------------------------------------------------
# 4) MERMAID АТТАЧ-CHAIN — ТОЖЕ PLAIN TEXT (НЕ HTML)
# ---------------------------------------------------------
@app.get("/scan/{scan_id}/chain")
async def api_get_chain(scan_id: int):
    mermaid_code = build_attack_chain_mermaid(scan_id)

    if not mermaid_code:
        raise HTTPException(status_code=404, detail="chain not available")

    return PlainTextResponse(mermaid_code)


# -----------------------------------------------------
# 5) ПОЛУЧЕНИЕ ГОТОВОГО ОТЧЁТА — ЧИСТЫЙ JSON
# -----------------------------------------------------
@app.get("/report/{scan_id}")
async def api_get_report(scan_id: int):
    db = SessionLocal()
    scan = get_scan_or_404(db, scan_id)
    db.close()

    if not scan.report_content:
        raise HTTPException(status_code=404, detail="report not ready")

    return JSONResponse({"scan_id": scan.id, "report": scan.report_content})


# ---------------------------------------------------------
# 6) КНОПКИ СТАТУСА ДЛЯ ПАНЕЛЕЙ (JSON, НЕ HTML)
# ---------------------------------------------------------
@app.get("/scan/{scan_id}/status")
async def api_scan_status(scan_id: int):
    db = SessionLocal()
    scan = get_scan_or_404(db, scan_id)
    db.close()

    return JSONResponse(
        {
            "id": scan_id,
            "status": scan.status,
            "ready": scan.status in ["finished", "failed"],
            "report_ready": bool(scan.report_content),
        }
    )


# --- Основной воркер сканирования ---
def worker_run_full_scan(scan_id: int, target: str):
    asyncio.run(run_full_scan(scan_id, target))


async def run_full_scan(scan_id: int, target: str):
    db = SessionLocal()
    update_scan_status(db, scan_id, "running: nmap")
    db.close()

    async with local_session() as session:
        await crud_scan.update(db=session, id=str(scan_id), object={"status": "running: nmap"})

    # --- ЭТАП 1: Nmap ---
    run_nmap_scan(scan_id, target)

    # --- ЭТАП 2: Nuclei ---
    db = SessionLocal()
    update_scan_status(db, scan_id, "running: nuclei")
    db.close()
    run_nuclei_scan(scan_id, target)

    async with local_session() as session:
        await crud_scan.update(db=session, id=str(scan_id), object={"status": "running: nuclei"})

    # --- ЭТАП 3: Поиск эксплойтов и попытка эксплуатации (ИИ) ---
    db = SessionLocal()
    update_scan_status(db, scan_id, "running: exploitation")
    db.close()

    async with local_session() as session:
        await crud_scan.update(db=session, id=str(scan_id), object={"status": "running: exploitation"})

    if not OPENROUTER_API_KEY or OPENROUTER_API_KEY == "sk-or-v1-YOUR-KEY":
        db = SessionLocal()
        append_exploit_log(
            db,
            scan_id,
            "[WARNING] OPENROUTER_API_KEY не установлен. Фаза эксплуатации пропускается.",
        )
        db.close()
    else:
        db = SessionLocal()
        run_exploit_phase(db, scan_id, OPENROUTER_API_KEY)
        db.close()

    # --- ЭТАП 4: Генерация отчета ---
    db = SessionLocal()
    update_scan_status(db, scan_id, "running: reporting")
    scan = db.query(Scan).filter(Scan.id == scan_id).first()
    report_generator = ReportGenerator(scan, BDU_MAP)
    report_text = report_generator.generate()
    save_report(db, scan_id, report_text)
    db.close()

    async with local_session() as session:
        await crud_scan.update(db=session, id=str(scan_id), object={"status": "running: reporting"})

    # --- Завершение ---
    db = SessionLocal()
    update_scan_status(db, scan_id, "finished")
    db.close()
    print(f"Сканирование #{scan_id} для {target} завершено.")

    async with local_session() as session:
        await crud_scan.update(db=session, id=str(scan_id), object={"status": "finished"})


# --- Функции-исполнители для каждого этапа ---


def run_command(cmd: list, log_prefix: str, scan_id: int, output_appender):
    try:
        proc = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            encoding="utf-8",
            errors="replace",
        )
        for line in iter(proc.stdout.readline, ""):
            if line:
                db = SessionLocal()
                output_appender(db, scan_id, f"[{log_prefix}] " + line)
                db.close()
        proc.wait()
    except Exception as e:
        db = SessionLocal()
        output_appender(db, scan_id, f"[{log_prefix}] ОШИБКА: {e}\n")
        update_scan_status(db, scan_id, "failed")
        db.close()


def run_nmap_scan(scan_id: int, target: str):
    cmd = [NMAP_PATH, "-sV", "-sC", "-p", "21,22,23,80,443,8080", target]
    run_command(cmd, "nmap", scan_id, append_scan_output)


def run_nuclei_scan(scan_id: int, target: str):
    cmd = [NUCLEI_PATH, "-u", target, "-tags", "cve", "-fr", "-duc", "-j"]
    run_command(cmd, "nuclei", scan_id, append_nuclei_output)
